import os
import shutil
import json
import traceback
import pkg_resources
import random
from .execute import execute


class Handler:
    def __init__(self, datapack_path: str, override: bool = True):
        """__init__ - Initalizes the Onyx handler. This is required to have any of the commands work.

        Args:
            datapack_path (str): The file path of where the datapack should generate.
            override (bool, optional): Whether or not the old datapack should be deleted. Defaults to True.
        """
        Handler._datapack_path = os.path.normpath(datapack_path)
        normalized_path = os.path.normpath(Handler._datapack_path)
        Handler._datapack_name = os.path.basename(normalized_path)

        # Initalize the path list and the loaded library list
        Handler._path_list = {}
        Handler._loaded_libs = []

        if override:
            shutil.rmtree(Handler._datapack_path, ignore_errors=True)
            # Generate file structure
            path = os.path.join(Handler._datapack_path, "data", Handler._datapack_name, "functions")
            os.makedirs(path, exist_ok=True)

            # Generate pack.mcmeta
            with open(os.path.join(Handler._datapack_path, "pack.mcmeta"), "w+") as mc_meta_file:
                mc_meta_data = {
                    "pack": {
                        "pack_format": 5,
                        "description": f"{Handler._datapack_name} | generated by Onyx"
                    }
                }
                json.dump(mc_meta_data, mc_meta_file, indent=4)

        Handler._status(f"Removed old datapack: {Handler._datapack_name}")

    # Path decorator
    @staticmethod
    def path(path: str):
        """path - A decorator which registers the function by creating the function file with parent folders and adding it to a list to be retrieved for later usage.

        Args:
            path (str): The location of the function. Only folders should be specified, as the function name is equal to the python function name itself.
        """
        def wrapper(function):
            # Normalize the path so "/" doesn't break
            new_path = os.path.join(Handler._datapack_path, "data", Handler._datapack_name, "functions", os.path.normpath(path))

            # Create the path in case it doesn't exist
            os.makedirs(new_path)

            # Assigns and registers the path in a list to be used by other methods
            Handler._working_path = new_path
            Handler._path_list[function.__name__] = Handler._working_path

            # Generate the mcfunction
            function()

            function_path = Handler._get_function_path(function.__name__)
            Handler._status(f"Generated new function: {Handler._datapack_name}:{function_path}")
            return function
        return wrapper

    # Loop decorator
    @staticmethod
    def loop(function):
        """loop - A decorator used to add a function to tick.json. Should always be placed above '@path()'.

        Args:
            function: Always equal to the function the decorator was used on.
        """
        def wrapper():
            # Make the tick.json directory if it doesn't exist
            tick_dir = os.path.join(Handler._datapack_path, "data", "minecraft", "tags", "functions")
            os.makedirs(tick_dir, exist_ok=True)

            # Get the tick.json contents and set default values if they don't exist
            try:
                with open(os.path.join(tick_dir, "tick.json"), "r") as tick_json:
                    current_data = json.load(tick_json)
            except FileNotFoundError:
                current_data = {"values": []}

            # Update (or create) the file
            with open(os.path.join(tick_dir, "tick.json"), "w+") as tick_json:
                # Get the function path, split it, and then keep only everything past /data/namespace/functions/
                function_path = Handler._get_function_path(function.__name__)

                # Add the data to the list and dump it
                current_data["values"].append(f"{Handler._datapack_name}:{function_path}")
                json.dump(current_data, tick_json, indent=4)

            Handler._status(f"Added function to tick.json: {Handler._datapack_name}:{function_path}")

            return function
        return wrapper()

    # Private method so I don't have to make a new "with" block with each file.
    # Special cases may still use "with open() as ..." (like "using")
    @staticmethod
    def _write(func_name, text):
        """_write - Writes a command to a file

        Args:
            func_name: The function to write to. Should almost always be 'inspect.stack()[1][3]'.
            text: The command to write
        """
        path = os.path.join(Handler._working_path, func_name + ".mcfunction")
        with open(path, "a") as _file:
            if isinstance(text, str):
                _file.write(f"{text}\n")
            elif isinstance(text, list):
                for cmd in text:
                    _file.write(f"{cmd}\n")

    # Print a warning in the terminal
    @staticmethod
    def _warn(text):
        """_warn - Prints a warning to the terminal which consists of a message and where the error was called

        Args:
            text: The warning text to display before the error location
        """
        # Gets the following info:
        # File "my:/file/path", line 87, in function_name
        #   function_call()
        traceback_loc = ''.join(traceback.format_list(traceback.extract_stack(limit=3)[:-2]))

        print(f"Warning: {text}")
        # Remove the last newline, then print the location and the warning text
        print(traceback_loc[:len(traceback_loc)-1])

    # Method is to make it more clear that it is for status messages
    @staticmethod
    def _status(text, end="\n"):
        """_status - Prints a status message to the terminal.

        Args:
            text: The text to print
            end (optional): The ending to place after the text. Can be changed if it needs to print on the same line. Defaults to "\\n".
        """
        print(f"{text}", end=end)

    # Used internally (mostly for _status)
    @staticmethod
    def _get_function_path(function):
        """_get_function_path - Fetches the function path that was registered when '@path()' was used

        Args:
            function: The function to retrieve

        Returns:
            str: The function path
        """
        function_path = Handler._path_list[function].split(os.sep)
        function_path = function_path[function_path.index('functions') + 1:]
        return f"{'/'.join(function_path)}/{function}"

    # Used internally for presets
    @staticmethod
    def _get_lib_dir():
        """_get_lib_dir - Get the directory of the onyx lib folder

        Returns:
            str: The directory of the onyx lib folder
        """
        lib_dir = os.path.normpath(pkg_resources.resource_filename("onyx", "lib/"))
        # Remove the unnessecary "onyx" that appears due to the above function call
        lib_dir = lib_dir.split(os.sep)
        lib_dir.reverse()
        lib_dir.remove("onyx")
        lib_dir.reverse()
        return '/'.join(lib_dir)

    # Used internally for presets
    @staticmethod
    def _load_lib(lib_name):
        """_load_lib - Loads an Onyx library from the 'pkg_dir/lib' folder

        Args:
            lib_name: The library to load (specified by enum value)
        """
        lib_files = []

        # Copy the lib from the onyx library to the datapack
        try:
            shutil.copytree(
                # src
                os.path.normpath(os.path.join(Handler._get_lib_dir(), lib_name.value)),
                # dst
                os.path.join(Handler._datapack_path, "data", Handler._datapack_name, "functions", "lib", lib_name.value)
            )

            # Get a list of files in the library folder
            for root, dirnames, files in os.walk(os.path.join(Handler._datapack_path, "data", Handler._datapack_name, "functions", "lib", lib_name.value)):
                for _file in files:
                    lib_files.append(root + os.sep + _file)
            os.chdir(os.path.join(Handler._datapack_path, "data", Handler._datapack_name, "functions", "lib", lib_name.value))

            for lib_file in lib_files:
                # Change the .onyxlib extension to .mcfunction
                lib_base_name = os.path.splitext(lib_file)[0]
                lib_mcfunction = lib_base_name + ".mcfunction"
                os.rename(lib_file, lib_mcfunction)

                # Replace the nessecary tags
                with open(lib_mcfunction, "r") as _file:
                    old_contents = _file.readlines()
                contents = []
                for line in old_contents:
                    line = line.replace(":datapack_name:", Handler._datapack_name)
                    line = line.replace(":random_num1:", str(random.randint(-2147483648, 2147483648)))
                    line = line.replace(":random_num2:", str(random.randint(-2147483648, 2147483648)))
                    line = line.replace(":random_num3:", str(random.randint(-2147483648, 2147483648)))
                    line = line.replace(":random_num4:", str(random.randint(-2147483648, 2147483648)))
                    contents.append(line)
                with open(lib_mcfunction, "w") as _file:
                    _file.write(''.join(contents))
        # The library file already exists
        except FileExistsError:
            pass

    @staticmethod
    def _get_differentiator(func_name):
        # Find the number to put at the end of the mcfunction name by looping through all numbers and checking if it exists
        for differentiator in range(1, 10000):
            # Keep searching for a new differentiator until one that is not in use is found
            if os.path.exists(os.path.join(Handler._working_path, "generated", f"{func_name}{differentiator}.mcfunction")):
                continue
            # The loop will only exit if it finds a differentiator that isn't in use
            break
        return str(differentiator)

    @staticmethod
    def _move_commands(func_name, preset, cmds):
        command_count = 0
        for cmd in cmds:
            if isinstance(cmd, str):
                command_count += 1
            elif isinstance(cmd, list):
                command_count += len(cmd)

        # Remove the commands that are part of the block
        with open(os.path.join(Handler._working_path, func_name + ".mcfunction"), "r") as _file:
            contents = _file.readlines()
            contents_without_commands = contents[:-command_count]

        with open(os.path.join(Handler._working_path, func_name + ".mcfunction"), "w") as _file:
            _file.write(''.join(contents_without_commands))

        # Make the generated folder if it doesn't exist
        os.makedirs(os.path.join(Handler._working_path, "generated"), exist_ok=True)

        differentiator = Handler._get_differentiator(func_name)

        # Write the seperated commands to the other file
        with open(os.path.join(Handler._working_path, "generated", f"{func_name}{differentiator}.mcfunction"), "w") as _file:
            for cmd in cmds:
                if isinstance(cmd, str):
                    _file.write(cmd + "\n")
                elif isinstance(cmd, list):
                    for q in cmd:
                        _file.write(q + "\n")

        # Get the function path and write the function call to the file
        function_path = Handler._get_function_path(func_name)
        if isinstance(preset, execute):
            preset = preset.output
        prefix = f"{preset}run " if preset else ""
        Handler._write(func_name, f"{prefix}function {Handler._datapack_name}:{function_path}/generated/{func_name}{differentiator}")

        Handler._status(f"Generated new function: {Handler._datapack_name}:{function_path}/generated/{func_name}{differentiator}")

    @staticmethod
    def _add_to_init(cmd):
        # Make the tick.json directory if it doesn't exist
        load_dir = os.path.join(Handler._datapack_path, "data", "minecraft", "tags", "functions")
        os.makedirs(load_dir, exist_ok=True)

        # Get the load.json contents and set default values if they don't exist
        try:
            with open(os.path.join(load_dir, "load.json"), "r") as load_json:
                current_data = json.load(load_json)
        except FileNotFoundError:
            current_data = {"values": []}
            Handler._status("Added 'init.mcfunction' to load.json")

        # Create the file
        with open(os.path.join(load_dir, "load.json"), "w+") as load_json:
            # Add the data to the list and dump it
            current_data["values"].append(f"{Handler._datapack_name}:init")
            json.dump(current_data, load_json, indent=4)

        with open(os.path.join(Handler._datapack_path, "data", Handler._datapack_name, "functions", "init.mcfunction"), "a") as init:
            if isinstance(cmd, list):
                init.write('\n'.join(cmd))
            elif isinstance(cmd, str):
                init.write(cmd + "\n")
        Handler._status(f"Added command to init: '{cmd}'")
