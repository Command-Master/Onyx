import os
import shutil
import json
import inspect
import traceback
from .execute import Execute

class Commands:
	@staticmethod
	def __init__(datapack_path: str, override=False):
		Commands._datapack_path = os.path.normpath(datapack_path)
		Commands._datapack_name = os.path.basename(os.path.normpath(Commands._datapack_path))
		Commands._path_list = {}

		if override:
			shutil.rmtree(Commands._datapack_path, ignore_errors=True)
			# Generate file structure  
			os.makedirs(os.path.join(Commands._datapack_path, "data", Commands._datapack_name, "functions"), exist_ok=True)

			# Generate pack.mcmeta
			with open(os.path.join(Commands._datapack_path, "pack.mcmeta"), "w+") as mc_meta_file:
				mc_meta_data = {"pack": {"pack_format": 5, "description": f"{Commands._datapack_name} | generated by Onyx"}}
				json.dump(mc_meta_data, mc_meta_file, indent=4)

	# Path decorator
	@staticmethod
	def path(path: str):
		def wrapper(function):
			# Normalize the path so "/" doesn't break
			new_path = os.path.normpath(path)

			# Create the path in case it doesn't exist
			os.makedirs(os.path.join(Commands._datapack_path, "data", Commands._datapack_name, "functions", new_path), exist_ok=True)

			# Assigns and registers the path in a list to be used by other methods 
			Commands._working_path = os.path.join(Commands._datapack_path, "data", Commands._datapack_name, "functions", new_path) 
			Commands._path_list[function.__name__] = Commands._working_path

			# Generate the mcfunction
			function()
			
			return function
		return wrapper

	# Loop decorator. 
	@staticmethod
	def loop(function):
		def wrapper():
			# Make the tick.json directory if it doesn't exist
			os.makedirs(os.path.join(Commands._datapack_path, "data", "minecraft", "tags", "functions"), exist_ok=True)

			# Get the tick.json contents and set default values if it doesn't exist
			try:
				with open(os.path.join(Commands._datapack_path, "data", "minecraft", "tags", "functions", "tick.json"), "r") as tick_json: 
					current_data = json.load(tick_json)
			except FileNotFoundError:
				current_data = {"values": []}
					
			# Update (or create) the file
			with open(os.path.join(Commands._datapack_path, "data", "minecraft", "tags", "functions", "tick.json"), "w+") as tick_json:
				# Get the function path, split it, and then keep only everything past /data/namespace/functions/
				function_path = Commands._path_list[function.__name__].split(os.sep)
				function_path = function_path[function_path.index('functions') + 1:]   

				# Add the data to the list and dump it
				current_data["values"].append(f"{Commands._datapack_name}:{'/'.join(function_path)}/{function.__name__}")
				json.dump(current_data, tick_json, indent=4)

			return function
		return wrapper()

	# Starts relative to /data/namespace/functions
	# Writes "function <datapack name>:<path>"" to the working path
	@staticmethod
	def call(function: callable):
		# Get the function path, split it, and then keep only everything past /data/namespace/functions/
		function_path = Commands._path_list[function.__name__].split(os.sep)
		function_path = function_path[function_path.index('functions') + 1:]   

		with open(os.path.join(Commands._working_path, inspect.stack()[1][3] + ".mcfunction"), "a") as function_file:
			function_file.write(f"function {Commands._datapack_name}:{' '.join(function_path)}/{function.__name__}\n")   

	# Send any command
	@staticmethod
	def send(cmd: str):
		Commands._write(inspect.stack()[1][3], cmd)

	# /say
	@staticmethod
	def say(text: str):
		Commands._write(inspect.stack()[1][3], f"say {text}")

	# Adds a comment to the function file with a custom amount of blank lines before and after
	@staticmethod
	def comment(text: str, preline=0, postline=0):
		for x in range(preline):
			Commands._write(inspect.stack()[1][3], "")
		Commands._write(inspect.stack()[1][3], f"# {text}")
		for x in range(postline):
			Commands._write(inspect.stack()[1][3], "")

	# Execute presets
	@staticmethod
	def using(execute_preset: Execute, cmds: tuple):
		# Get the file contents and seperate the commands and everything else
		with open(os.path.join(Commands._working_path, inspect.stack()[1][3] + ".mcfunction"), "r") as _file:
			contents = _file.readlines()
			contents_without_commands = contents[:-len(cmds)]
			commands = contents[-len(cmds):]
			
		# Remove the commands that are part of the execute block
		with open(os.path.join(Commands._working_path, inspect.stack()[1][3] + ".mcfunction"), "w") as _file:
			_file.write(''.join(contents_without_commands))
		
		# Make the generated folder if it doesn't exist
		os.makedirs(os.path.join(Commands._working_path, "generated"), exist_ok=True)

		# Find the number to put at the end of the mcfunction name by looping through all numbers and checking if it exists
		for differentiator in range(1, 1000000):
			# Keep searching for a new differentiator until one that is not in use is found
			if os.path.exists(os.path.join(Commands._working_path, "generated", f"{inspect.stack()[1][3]}{differentiator}.mcfunction")):
				continue
			# The loop will only exit if it finds a differentiator that isn't in use
			break

		# Write the seperated commands to the other file
		with open(os.path.join(Commands._working_path, "generated", f"{inspect.stack()[1][3]}{differentiator}.mcfunction"), "w") as _file:
			_file.write(''.join(commands))

		# Get the function path, split it, and then keep only everything past /data/namespace/functions/
		function_path = Commands._path_list[inspect.stack()[1][3]].split(os.sep)
		function_path = function_path[function_path.index('functions') + 1:]   
		Commands._write(inspect.stack()[1][3], f"{execute_preset.output}run function {Commands._datapack_name}:{' '.join(function_path)}/generated/{inspect.stack()[1][3]}{differentiator}")

	# Private method so I don't have to make a new "with" block with each file. Special cases may still use "with open() as ..." (like "using")
	@staticmethod
	def _write(func_name: callable, text: str):
		with open(os.path.join(Commands._working_path, func_name + ".mcfunction"), "a") as _file:
			_file.write(f"{text}\n")

	# Print a warning in the terminal
	@staticmethod
	def _warn(text: str):
		# Gets the following info:
		# File "my:/file/path", line 87, in function_name
    	#   function_call()
		traceback_loc = ''.join(traceback.format_list(traceback.extract_stack(limit=3)[:-2]))

		# Remove the last newline, then print the location and the warning text
		print(traceback_loc[:len(traceback_loc)-1])
		print(f"Warning: {text}\n")